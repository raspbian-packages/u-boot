From 0bea813d0018303610ec487314003c21f0116a21 Mon Sep 17 00:00:00 2001
From: Lokesh Vutla <lokeshvutla@ti.com>
Date: Wed, 24 Feb 2016 12:30:54 -0600
Subject: [PATCH 1/2] ARM: omap-common: Add standard access for board
 description EEPROM

Several TI EVMs have EEPROM that can contain board description information
such as revision, DDR definition, serial number, etc. In just about all
cases, these EEPROM are on the I2C bus and provides us the opportunity
to centralize the generic operations involved.

The on-board EEPROM on the BeagleBone Black, BeagleBone, AM335x EVM,
AM43x GP EVM, AM57xx-evm, BeagleBoard-X15 share the same format.
However, DRA-7* EVMs, OMAP4SDP use a modified format.

We hence introduce logic which is generic between these platforms
without enforcing any specific format. This allows the boards to use the
relevant format for operations that they might choose.

This module will compile for all TI SoC based boards when
CONFIG_TI_I2C_BOARD_DETECT is enabled to have optimal build times for
platforms that require this support.

It is important to note that this logic is fundamental to the board
configuration process such as DDR configuration which is needed in
SPL, hence cannot be part of the standard u-boot driver model (which
is available later in the process). Hence, to aid efficiency, the
eeprom contents are copied over to SRAM scratchpad memory area at the
first invocation to retrieve data.

To prevent churn with cases such as DRA7, where eeprom format maybe
incompatible, we introduce a generic common format in eeprom which
is made available over accessor functions for usage.

Special handling for BBG1 EEPROM had to be introduced thanks to the
weird eeprom rev contents used.

The follow on patches introduce the use of this library for AM335x,
AM437x, and AM57xx.

Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
Signed-off-by: Steve Kipisz <s-kipisz2@ti.com>
Signed-off-by: Roger Quadros <rogerq@ti.com>
Signed-off-by: Nishanth Menon <nm@ti.com>
Reviewed-by: Tom Rini <trini@konsulko.com>
---
 arch/arm/include/asm/omap_common.h |   4 +-
 board/ti/common/Kconfig            |   5 +
 board/ti/common/Makefile           |   6 +
 board/ti/common/board_detect.c     | 254 +++++++++++++++++++++++++++++++++++++
 board/ti/common/board_detect.h     | 140 ++++++++++++++++++++
 5 files changed, 408 insertions(+), 1 deletion(-)

diff --git a/arch/arm/include/asm/omap_common.h b/arch/arm/include/asm/omap_common.h
index d773b04..aef3126 100644
--- a/arch/arm/include/asm/omap_common.h
+++ b/arch/arm/include/asm/omap_common.h
@@ -713,7 +713,9 @@ static inline u8 is_dra72x(void)
 #define OMAP_SRAM_SCRATCH_VCORES_PTR    (SRAM_SCRATCH_SPACE_ADDR + 0x1C)
 #define OMAP_SRAM_SCRATCH_SYS_CTRL	(SRAM_SCRATCH_SPACE_ADDR + 0x20)
 #define OMAP_SRAM_SCRATCH_BOOT_PARAMS	(SRAM_SCRATCH_SPACE_ADDR + 0x24)
-#define OMAP5_SRAM_SCRATCH_SPACE_END	(SRAM_SCRATCH_SPACE_ADDR + 0x28)
+#define OMAP_SRAM_SCRATCH_BOARD_EEPROM_START (SRAM_SCRATCH_SPACE_ADDR + 0x28)
+#define OMAP_SRAM_SCRATCH_BOARD_EEPROM_END (SRAM_SCRATCH_SPACE_ADDR + 0x200)
+#define OMAP_SRAM_SCRATCH_SPACE_END	(OMAP_SRAM_SCRATCH_BOARD_EEPROM_END)
 
 /* Boot parameters */
 #define DEVICE_DATA_OFFSET	0x18
diff --git a/board/ti/common/Kconfig b/board/ti/common/Kconfig
new file mode 100644
index 0000000..adf73ab
--- /dev/null
+++ b/board/ti/common/Kconfig
@@ -0,0 +1,5 @@
+config TI_I2C_BOARD_DETECT
+	bool "Support for Board detection for TI platforms"
+	help
+	   Support for detection board information on Texas Instrument's
+	   Evaluation Boards which have I2C based EEPROM detection
diff --git a/board/ti/common/Makefile b/board/ti/common/Makefile
new file mode 100644
index 0000000..7170eac
--- /dev/null
+++ b/board/ti/common/Makefile
@@ -0,0 +1,6 @@
+# Copyright (C) 2015-2016 Texas Instruments Incorporated - http://www.ti.com/
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-${CONFIG_TI_I2C_BOARD_DETECT} += board_detect.o
diff --git a/board/ti/common/board_detect.c b/board/ti/common/board_detect.c
new file mode 100644
index 0000000..6cf4859
--- /dev/null
+++ b/board/ti/common/board_detect.c
@@ -0,0 +1,254 @@
+/*
+ * Library to support early TI EVM EEPROM handling
+ *
+ * Copyright (C) 2015-2016 Texas Instruments Incorporated - http://www.ti.com/
+ *	Lokesh Vutla
+ *	Steve Kipisz
+ *
+ * SPDX-License-Identifier:    GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/omap_common.h>
+#include <i2c.h>
+
+#include "board_detect.h"
+
+/**
+ * ti_i2c_eeprom_init - Initialize an i2c bus and probe for a device
+ * @i2c_bus: i2c bus number to initialize
+ * @dev_addr: Device address to probe for
+ *
+ * Return: 0 on success or corresponding error on failure.
+ */
+static int __maybe_unused ti_i2c_eeprom_init(int i2c_bus, int dev_addr)
+{
+	int rc;
+
+	if (i2c_bus >= 0) {
+		rc = i2c_set_bus_num(i2c_bus);
+		if (rc)
+			return rc;
+	}
+
+	return i2c_probe(dev_addr);
+}
+
+/**
+ * ti_i2c_eeprom_read - Read data from an EEPROM
+ * @dev_addr: The device address of the EEPROM
+ * @offset: Offset to start reading in the EEPROM
+ * @ep: Pointer to a buffer to read into
+ * @epsize: Size of buffer
+ *
+ * Return: 0 on success or corresponding result of i2c_read
+ */
+static int __maybe_unused ti_i2c_eeprom_read(int dev_addr, int offset,
+					     uchar *ep, int epsize)
+{
+	return i2c_read(dev_addr, offset, 2, ep, epsize);
+}
+
+/**
+ * ti_eeprom_string_cleanup() - Handle eeprom programming errors
+ * @s:	eeprom string (should be NULL terminated)
+ *
+ * Some Board manufacturers do not add a NULL termination at the
+ * end of string, instead some binary information is kludged in, hence
+ * convert the string to just printable characters of ASCII chart.
+ */
+static void __maybe_unused ti_eeprom_string_cleanup(char *s)
+{
+	int i, l;
+
+	l = strlen(s);
+	for (i = 0; i < l; i++, s++)
+		if (*s < ' ' || *s > '~') {
+			*s = 0;
+			break;
+		}
+}
+
+__weak void gpi2c_init(void)
+{
+}
+
+static int __maybe_unused ti_i2c_eeprom_get(int bus_addr, int dev_addr,
+					    u32 header, u32 size, uint8_t *ep)
+{
+	u32 byte, hdr_read;
+	int rc;
+
+	gpi2c_init();
+	rc = ti_i2c_eeprom_init(bus_addr, dev_addr);
+	if (rc)
+		return rc;
+
+	/*
+	 * Read the header first then only read the other contents.
+	 */
+	byte = 2;
+	rc = i2c_read(dev_addr, 0x0, byte, (uint8_t *)&hdr_read, 4);
+	if (rc)
+		return rc;
+
+	/* Corrupted data??? */
+	if (hdr_read != header) {
+		rc = i2c_read(dev_addr, 0x0, byte, (uint8_t *)&hdr_read, 4);
+		/*
+		 * read the eeprom header using i2c again, but use only a
+		 * 1 byte address (some legacy boards need this..)
+		 */
+		byte = 1;
+		if (rc)
+			rc = i2c_read(dev_addr, 0x0, byte, (uint8_t *)&hdr_read,
+				      4);
+		if (rc)
+			return rc;
+	}
+	if (hdr_read != header)
+		return -1;
+
+	rc = i2c_read(dev_addr, 0x0, byte, ep, size);
+	if (rc)
+		return rc;
+
+	return 0;
+}
+
+int __maybe_unused ti_i2c_eeprom_am_get(int bus_addr, int dev_addr)
+{
+	int rc;
+	struct ti_am_eeprom am_ep;
+	struct ti_common_eeprom *ep;
+
+	ep = TI_EEPROM_DATA;
+	if (ep->header == TI_EEPROM_HEADER_MAGIC)
+		goto already_read;
+
+	/* Initialize with a known bad marker for i2c fails.. */
+	ep->header = TI_DEAD_EEPROM_MAGIC;
+	ep->name[0] = 0x0;
+	ep->version[0] = 0x0;
+	ep->serial[0] = 0x0;
+
+	rc = ti_i2c_eeprom_get(bus_addr, dev_addr, TI_EEPROM_HEADER_MAGIC,
+			       sizeof(am_ep), (uint8_t *)&am_ep);
+	if (rc)
+		return rc;
+
+	ep->header = am_ep.header;
+	strlcpy(ep->name, am_ep.name, TI_EEPROM_HDR_NAME_LEN + 1);
+	ti_eeprom_string_cleanup(ep->name);
+
+	/* BeagleBone Green '1' eeprom, board_rev: 0x1a 0x00 0x00 0x00 */
+	if (am_ep.version[0] == 0x1a && am_ep.version[1] == 0x00 &&
+	    am_ep.version[2] == 0x00 && am_ep.version[3] == 0x00)
+		strlcpy(ep->version, "BBG1", TI_EEPROM_HDR_REV_LEN + 1);
+	else
+		strlcpy(ep->version, am_ep.version, TI_EEPROM_HDR_REV_LEN + 1);
+	ti_eeprom_string_cleanup(ep->version);
+	strlcpy(ep->serial, am_ep.serial, TI_EEPROM_HDR_SERIAL_LEN + 1);
+	ti_eeprom_string_cleanup(ep->serial);
+	strlcpy(ep->config, am_ep.config, TI_EEPROM_HDR_CONFIG_LEN + 1);
+	ti_eeprom_string_cleanup(ep->config);
+
+	memcpy(ep->mac_addr, am_ep.mac_addr,
+	       TI_EEPROM_HDR_NO_OF_MAC_ADDR * TI_EEPROM_HDR_ETH_ALEN);
+
+already_read:
+	return 0;
+}
+
+bool __maybe_unused board_ti_is(char *name_tag)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header == TI_DEAD_EEPROM_MAGIC)
+		return false;
+	return !strncmp(ep->name, name_tag, TI_EEPROM_HDR_NAME_LEN);
+}
+
+bool __maybe_unused board_ti_rev_is(char *rev_tag, int cmp_len)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+	int l;
+
+	if (ep->header == TI_DEAD_EEPROM_MAGIC)
+		return false;
+
+	l = cmp_len > TI_EEPROM_HDR_REV_LEN ? TI_EEPROM_HDR_REV_LEN : cmp_len;
+	return !strncmp(ep->version, rev_tag, l);
+}
+
+char * __maybe_unused board_ti_get_rev(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header == TI_DEAD_EEPROM_MAGIC)
+		return NULL;
+
+	return ep->version;
+}
+
+char * __maybe_unused board_ti_get_config(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header == TI_DEAD_EEPROM_MAGIC)
+		return NULL;
+
+	return ep->config;
+}
+
+char * __maybe_unused board_ti_get_name(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header == TI_DEAD_EEPROM_MAGIC)
+		return NULL;
+
+	return ep->name;
+}
+
+void __maybe_unused
+board_ti_get_eth_mac_addr(int index,
+			  u8 mac_addr[TI_EEPROM_HDR_ETH_ALEN])
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header == TI_DEAD_EEPROM_MAGIC)
+		goto fail;
+
+	if (index < 0 || index >= TI_EEPROM_HDR_NO_OF_MAC_ADDR)
+		goto fail;
+
+	memcpy(mac_addr, ep->mac_addr[index], TI_EEPROM_HDR_ETH_ALEN);
+	return;
+
+fail:
+	memset(mac_addr, 0, TI_EEPROM_HDR_ETH_ALEN);
+}
+
+void __maybe_unused set_board_info_env(char *name)
+{
+	char *unknown = "unknown";
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (name)
+		setenv("board_name", name);
+	else if (ep->name)
+		setenv("board_name", ep->name);
+	else
+		setenv("board_name", unknown);
+
+	if (ep->version)
+		setenv("board_rev", ep->version);
+	else
+		setenv("board_rev", unknown);
+
+	if (ep->serial)
+		setenv("board_serial", ep->serial);
+	else
+		setenv("board_serial", unknown);
+}
diff --git a/board/ti/common/board_detect.h b/board/ti/common/board_detect.h
new file mode 100644
index 0000000..c17ab34
--- /dev/null
+++ b/board/ti/common/board_detect.h
@@ -0,0 +1,140 @@
+/*
+ * Library to support early TI EVM EEPROM handling
+ *
+ * Copyright (C) 2015-2016 Texas Instruments Incorporated - http://www.ti.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __BOARD_DETECT_H
+#define __BOARD_DETECT_H
+
+/* TI EEPROM MAGIC Header identifier */
+#define TI_EEPROM_HEADER_MAGIC	0xEE3355AA
+#define TI_DEAD_EEPROM_MAGIC	0xADEAD12C
+
+#define TI_EEPROM_HDR_NAME_LEN		8
+#define TI_EEPROM_HDR_REV_LEN		4
+#define TI_EEPROM_HDR_SERIAL_LEN	12
+#define TI_EEPROM_HDR_CONFIG_LEN	32
+#define TI_EEPROM_HDR_NO_OF_MAC_ADDR	3
+#define TI_EEPROM_HDR_ETH_ALEN		6
+
+/**
+ * struct ti_am_eeprom - This structure holds data read in from the
+ *                     AM335x, AM437x, AM57xx TI EVM EEPROMs.
+ * @header: This holds the magic number
+ * @name: The name of the board
+ * @version: Board revision
+ * @serial: Board serial number
+ * @config: Reserved
+ * @mac_addr: Any MAC addresses written in the EEPROM
+ *
+ * The data is this structure is read from the EEPROM on the board.
+ * It is used for board detection which is based on name. It is used
+ * to configure specific TI boards. This allows booting of multiple
+ * TI boards with a single MLO and u-boot.
+ */
+struct ti_am_eeprom {
+	unsigned int header;
+	char name[TI_EEPROM_HDR_NAME_LEN];
+	char version[TI_EEPROM_HDR_REV_LEN];
+	char serial[TI_EEPROM_HDR_SERIAL_LEN];
+	char config[TI_EEPROM_HDR_CONFIG_LEN];
+	char mac_addr[TI_EEPROM_HDR_NO_OF_MAC_ADDR][TI_EEPROM_HDR_ETH_ALEN];
+} __attribute__ ((__packed__));
+
+/**
+ * struct ti_common_eeprom - Null terminated, usable EEPROM contents.
+ * header:	Magic number
+ * @name:	NULL terminated name
+ * @version:	NULL terminated version
+ * @serial:	NULL terminated serial number
+ * @config:	NULL terminated Board specific config options
+ * @mac_addr:	MAC addresses
+ */
+struct ti_common_eeprom {
+	u32 header;
+	char name[TI_EEPROM_HDR_NAME_LEN + 1];
+	char version[TI_EEPROM_HDR_REV_LEN + 1];
+	char serial[TI_EEPROM_HDR_SERIAL_LEN + 1];
+	char config[TI_EEPROM_HDR_CONFIG_LEN + 1];
+	char mac_addr[TI_EEPROM_HDR_NO_OF_MAC_ADDR][TI_EEPROM_HDR_ETH_ALEN];
+};
+
+#define TI_EEPROM_DATA ((struct ti_common_eeprom *)\
+				OMAP_SRAM_SCRATCH_BOARD_EEPROM_START)
+
+/**
+ * ti_i2c_eeprom_am_get() - Consolidated eeprom data collection for AM* TI EVMs
+ * @bus_addr:	I2C bus address
+ * @dev_addr:	I2C slave address
+ *
+ * ep in SRAM is populated by the this AM generic function that consolidates
+ * the basic initialization logic common across all AM* platforms.
+ */
+int ti_i2c_eeprom_am_get(int bus_addr, int dev_addr);
+
+/**
+ * board_ti_is() - Board detection logic for TI EVMs
+ * @name_tag:	Tag used in eeprom for the board
+ *
+ * Return: false if board information does not match OR eeprom wasn't read.
+ *	   true otherwise
+ */
+bool board_ti_is(char *name_tag);
+
+/**
+ * board_ti_rev_is() - Compare board revision for TI EVMs
+ * @rev_tag:	Revision tag to check in eeprom
+ * @cmp_len:	How many chars to compare?
+ *
+ * NOTE: revision information is often messed up (hence the str len match) :(
+ *
+ * Return: false if board information does not match OR eeprom was'nt read.
+ *	   true otherwise
+ */
+bool board_ti_rev_is(char *rev_tag, int cmp_len);
+
+/**
+ * board_ti_get_rev() - Get board revision for TI EVMs
+ *
+ * Return: NULL if eeprom was'nt read.
+ *	   Board revision otherwise
+ */
+char *board_ti_get_rev(void);
+
+/**
+ * board_ti_get_config() - Get board config for TI EVMs
+ *
+ * Return: NULL if eeprom was'nt read.
+ *	   Board config otherwise
+ */
+char *board_ti_get_config(void);
+
+/**
+ * board_ti_get_name() - Get board name for TI EVMs
+ *
+ * Return: NULL if eeprom was'nt read.
+ *	   Board name otherwise
+ */
+char *board_ti_get_name(void);
+
+/**
+ * board_ti_get_eth_mac_addr() - Get Ethernet MAC address from EEPROM MAC list
+ * @index:	0 based index within the list of MAC addresses
+ * @mac_addr:	MAC address contained at the index is returned here
+ *
+ * Does not sanity check the mac_addr. Whatever is stored in EEPROM is returned.
+ */
+void board_ti_get_eth_mac_addr(int index, u8 mac_addr[TI_EEPROM_HDR_ETH_ALEN]);
+
+/**
+ * set_board_info_env() - Setup commonly used board information environment vars
+ * @name:	Name of the board
+ *
+ * If name is NULL, default_name is used.
+ */
+void set_board_info_env(char *name);
+
+#endif	/* __BOARD_DETECT_H */
-- 
2.1.4

